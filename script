-- LocalScript â€” Aimlock + full-body ESP (screen-sized bounding box)
-- Place in StarterPlayer > StarterPlayerScripts

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

-- Settings
local SETTINGS = {
	MinRadius = 60,
	MaxRadius = 350,
	DefaultRadius = 160,

	MinSmooth = 0.05,
	MaxSmooth = 0.5,
	DefaultSmooth = 0.15,

	CircleThickness = 3,
	ToggleKey = Enum.KeyCode.Q,
	PanelToggleKey = Enum.KeyCode.RightShift,

	ESPColor = Color3.fromRGB(0, 255, 0),
	IgnoreTeammates = true, -- default ON
}

-- State
local AimlockEnabled = true
local ESPEnabled = true
local PanelVisible = true
local CircleRadius = SETTINGS.DefaultRadius
local Smoothness = SETTINGS.DefaultSmooth
local DraggingSlider = nil
local CurrentTarget
local TargetPart -- ðŸŽ¯ stores the random body part we picked

-- Utility: safe GetBoundingBox fallback
local function safeGetBoundingBox(model)
	local ok, cf, size = pcall(function() return model:GetBoundingBox() end)
	if ok and cf and size then
		return cf, size
	end

	-- fallback approximate bounding box from parts (axis-aligned)
	local minX, minY, minZ = math.huge, math.huge, math.huge
	local maxX, maxY, maxZ = -math.huge, -math.huge, -math.huge
	local found = false
	for _,v in ipairs(model:GetDescendants()) do
		if v:IsA("BasePart") then
			found = true
			local p = v.Position
			local half = v.Size * 0.5
			minX = math.min(minX, p.X - half.X)
			minY = math.min(minY, p.Y - half.Y)
			minZ = math.min(minZ, p.Z - half.Z)
			maxX = math.max(maxX, p.X + half.X)
			maxY = math.max(maxY, p.Y + half.Y)
			maxZ = math.max(maxZ, p.Z + half.Z)
		end
	end
	if not found then return nil end
	local center = Vector3.new((minX+maxX)/2, (minY+maxY)/2, (minZ+maxZ)/2)
	local size = Vector3.new(maxX-minX, maxY-minY, maxZ-minZ)
	return CFrame.new(center), size
end

-- ðŸŽ¯ Get all possible target parts of a character
local function getTargetParts(char)
	local parts = {}
	for _, v in ipairs(char:GetChildren()) do
		if v:IsA("BasePart") then
			table.insert(parts, v)
		end
	end
	return parts
end

-- ESP creation & update
local function ensureESPForPlayer(player)
	local char = player.Character
	if not char then return nil end
	local hrp = char:FindFirstChild("HumanoidRootPart")
	local hum = char:FindFirstChildOfClass("Humanoid")
	if not hrp or not hum then return nil end

	local esp = hrp:FindFirstChild("AimlockESP")
	if not esp then
		esp = Instance.new("BillboardGui")
		esp.Name = "AimlockESP"
		esp.Adornee = hrp
		esp.AlwaysOnTop = true
		esp.Parent = hrp
		esp.MaxDistance = 1e6
		esp.Size = UDim2.fromOffset(40, 80)

		local box = Instance.new("Frame")
		box.Name = "Box"
		box.Size = UDim2.fromScale(1, 1)
		box.BackgroundColor3 = SETTINGS.ESPColor
		box.BackgroundTransparency = 0.6
		box.BorderSizePixel = 0
		box.Parent = esp
	end

	esp.Enabled = ESPEnabled
	return esp
end

-- (UI code unchanged, skipped for brevity â€” keep your same UI from before)

-- Helpers
local function isAlive(char)
	if not char then return false end
	local hum = char:FindFirstChildOfClass("Humanoid")
	return hum and hum.Health > 0
end

local function getHead(char)
	return char and char:FindFirstChild("Head")
end

local function dist2(a,b)
	local dx, dy = a.X - b.X, a.Y - b.Y
	return math.sqrt(dx*dx + dy*dy)
end

local function hasLineOfSight(part, char)
	if not part or not char then return false end
	local params = RaycastParams.new()
	params.FilterType = Enum.RaycastFilterType.Blacklist
	params.FilterDescendantsInstances = {char, LocalPlayer.Character}
	local origin = Camera.CFrame.Position
	local dir = (part.Position - origin)
	local result = Workspace:Raycast(origin, dir, params)
	return result == nil
end

-- find target inside circle, visible, obeying team toggle
local function findTarget()
	local vp = Camera.ViewportSize
	local center = Vector2.new(vp.X * 0.5, vp.Y * 0.5)
	local bestPlayer = nil
	local bestDist = math.huge

	for _, plr in ipairs(Players:GetPlayers()) do
		if plr ~= LocalPlayer then
			if SETTINGS.IgnoreTeammates and plr.Team == LocalPlayer.Team then
				-- skip teammate
			else
				local char = plr.Character
				if isAlive(char) then
					local head = getHead(char)
					if head then
						local screen = Camera:WorldToViewportPoint(head.Position)
						if screen.Z > 0 then
							local pt = Vector2.new(screen.X, screen.Y)
							local d = dist2(pt, center)
							if d <= CircleRadius and d < bestDist then
								if hasLineOfSight(head, char) then
									bestDist = d
									bestPlayer = plr
								end
							end
						end
					end
				end
			end
		end
	end

	return bestPlayer
end

-- Update loop
RunService.RenderStepped:Connect(function()
	-- ESP update (same as before, unchanged)...

	if not AimlockEnabled then
		CurrentTarget, TargetPart = nil, nil
		return
	end

	local newTarget = findTarget()
	if newTarget ~= CurrentTarget then
		-- ðŸŽ¯ New target found, choose a random body part
		CurrentTarget = newTarget
		if CurrentTarget and CurrentTarget.Character then
			local parts = getTargetParts(CurrentTarget.Character)
			if #parts > 0 then
				TargetPart = parts[math.random(1, #parts)]
			else
				TargetPart = getHead(CurrentTarget.Character)
			end
		else
			TargetPart = nil
		end
	end

	if CurrentTarget and TargetPart then
		local camPos = Camera.CFrame.Position
		local desired = CFrame.lookAt(camPos, TargetPart.Position)
		Camera.CFrame = Camera.CFrame:Lerp(desired, math.clamp(Smoothness, 0, 1))
	end
end)
